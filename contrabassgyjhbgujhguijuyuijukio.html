<!DOCTYPE html>
<html lang="ja">
<head>
<link rel="apple-touch-icon" href="icon.png">

<meta name="apple-mobile-web-app-title" content="ã‚³ãƒ³ãƒˆãƒ©ãƒã‚¹è‡ªå‹•é‹æŒ‡å…¥åŠ›">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<meta name="viewport" content="width=device-width, initial-scale=1.0, <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<script src="https://unpkg.com/opensheetmusicdisplay@1.8.8/build/opensheetmusicdisplay.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        body { background: #f0f0f0; text-align: center; font-family: sans-serif; margin: 0; }
        #error-display { display: none; background: #e74c3c; color: white; padding: 15px; margin: 10px; border-radius: 5px; font-weight: bold; }
        .controls { background: #2c3e50; padding: 15px; position: fixed; top: 0; left: 0; width: 100%; z-index: 1060; color: white; box-sizing: border-box; }
        #wrapper { position: relative; display: block; margin: 80px auto 0 auto; 
            background: white; width: 1060px; }
        body { overflow-x: auto; }
        #score-container { position: relative; z-index: 1; width: 100%; }
        #finger-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 100; pointer-events: none; background: transparent !important; }
        button { padding: 12px 25px; cursor: pointer; border: none; color: white; border-radius: 5px; font-weight: bold; background: #27ae60; font-size: 1.1em; }
        button:disabled { background: #7f8c8d; cursor: not-allowed; }
        .toggle-btn { background: #7f8c8d; margin-left: 10px; font-size: 0.9em; padding: 10px 20px; }
        .toggle-btn.active-acc { background: #e67e22; }
        .toggle-btn.active-key { background: #ff00ff; }
.instrument-btn { background: #3498db; margin-left: 10px; font-size: 0.9em; padding: 10px 20px; }
.instrument-btn.active { background: #e74c3c; font-weight: bold; }
#status { font-size: 14px;
margin-top: 5px; color: #bdc3c7; }

/* æ“ä½œãƒ–ãƒ­ãƒƒã‚¯ç”¨ãƒ¬ã‚¤ãƒ¤ãƒ¼:éŸ³æ¥½çš„æ¼”å‡º */

        /* æ“ä½œãƒ–ãƒ­ãƒƒã‚¯ç”¨ãƒ¬ã‚¤ãƒ¤ãƒ¼:éŸ³æ¥½çš„æ¼”å‡º */
        #input-blocker { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 99999; display: none; cursor: wait;
            background: rgba(44, 62, 80, 0.1); /* ã»ã‚“ã®ã‚Šé’ã¿ãŒã‹ã£ãŸã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ */
            backdrop-filter: blur(1px); /* è»½ãã¼ã‹ã—ã¦é›†ä¸­æ„Ÿã‚’å‡ºã™ */
        }

        /* ã‚¹ã‚­ãƒ£ãƒ³ãƒ©ã‚¤ãƒ³ï¼ˆç·‘è‰²ã®ç·šï¼‰ã®åŸºæœ¬ã‚¹ã‚¿ã‚¤ãƒ« */
        #scan-line {
            position: fixed; /* ç”»é¢ã«å¯¾ã—ã¦å›ºå®š */
            left: 0; width: 100%; height: 100px; 
            /* ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’åè»¢ï¼šä¸‹ãŒæ¿ƒãã€ä¸Šã«å‘ã‹ã£ã¦æ¶ˆãˆã‚‹ */
            background: linear-gradient(0deg, rgba(39, 174, 96, 0.4) 0%, rgba(39, 174, 96, 0) 100%);
            border-bottom: 3px solid #27ae60; /* å…ˆç«¯ã®ç·šã‚’ä¸‹å´ã«é…ç½® */
            box-shadow: 0 5px 15px rgba(39, 174, 96, 0.5);
            /* åˆæœŸä½ç½®ã‚’èª¿æ•´ï¼ˆé«˜ã•åˆ†ã€ä¸Šã«éš ã™ï¼‰ */
            transform: translateY(-100px);
            z-index: 100000;
            pointer-events: none;
            display: none;
            /* opacityã®ã¿æ»‘ã‚‰ã‹ã«ã—ã€topã®ç§»å‹•ã¯JSã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã«ä»»ã›ã‚‹ */
            transition: opacity 0.5s; 
        }

        /* ç”»é¢ä¸­å¤®ã«è¡¨ç¤ºã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ */
        #scan-message {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #27ae60;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0,0,0,0.5);
            animation: pulse 1.5s ease-in-out infinite;
        }

        /* â˜…å¤‰æ›´ç®‡æ‰€: å‡¦ç†ä¸­ã®å¢ƒç•Œï¼ˆä¸­å¤®ä»˜è¿‘ï¼‰ã‹ã‚‰ä¸‹éƒ¨ã¸å‘ã‹ã†å‹•ãã«å¤‰æ›´ */
        @keyframes scan-move {
            0% { 
                top: 0%;
                opacity: 0; 
            }
            10% { 
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% { 
                top: 100%;
                opacity: 0; 
            }
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.6; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
        }
        
        /* PDFãƒ‡ãƒãƒƒã‚°ç”¨ã‚¹ã‚¿ã‚¤ãƒ« */
        .debug-marker { pointer-events: none; }
    </style>
</head>
<body>
    <div id="error-display"></div>
    <div class="controls">
    <input type="file" id="file-input" accept=".xml,.musicxml" />
    <button id="cello-btn" class="instrument-btn">ğŸ» ãƒã‚§ãƒ­</button>
    <button id="bass-btn" class="instrument-btn active">ğŸ¼ ã‚³ãƒ³ãƒˆãƒ©ãƒã‚¹</button>
    <button id="scan-btn">â˜†é‹æŒ‡ã‚’è¡¨ç¤º</button>
    <button id="toggle-acc-btn" class="toggle-btn active-acc">è‡¨æ™‚è¨˜å·ã‚¬ã‚¤ãƒ‰è¡¨ç¤º</button>
        <button id="toggle-key-btn" class="toggle-btn active-key">èª¿å·ã‚¬ã‚¤ãƒ‰è¡¨ç¤º</button>
        <button id="pdf-btn" style="background: #e74c3c;">ğŸ“„ PDFä¿å­˜</button>
        <div id="status">MusicXMLãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„</div>
    </div>

    <div id="wrapper">
        <div id="score-container"></div>
        <svg id="finger-layer" xmlns="http://www.w3.org/2000/svg"></svg>
    </div>
    
    <div id="input-blocker">
        <div id="scan-overlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; background-image: radial-gradient(rgba(39, 174, 96, 0.1) 1px, transparent 1px); background-size: 30px 30px;">
            <div id="scan-line"></div>
        </div>
        <div id="scan-message">ğŸµ AI Scanning Score... ğŸ»</div>
    </div>

    <script>
        let osmd = null;
        let currentInstrument = 'bass'; // 'bass' or 'cello'
	
        const drawnClefs = new Set(); // æç”»æ¸ˆã¿ã‚¯ãƒ¬ãƒ•(äº”ç·šè­œ)ã‚’è¨˜éŒ²

        // ã‚¨ãƒ©ãƒ¼è¡¨ç¤ºé–¢æ•°ã‚’è¿½åŠ 
function showError(msg) {
    const errDiv = document.getElementById('error-display');
    if (errDiv) {
        errDiv.innerText = msg;
        errDiv.style.display = 'block';
    } else {
        console.error(msg);
    }
}

// OSMDåˆæœŸåŒ–é–¢æ•°ã‚’è¿½åŠ 
async function initOSMD() {
    const container = document.getElementById("score-container");
    
    if (typeof opensheetmusicdisplay === 'undefined') {
        showError("OSMDãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆæ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚");
        return false;
    }

    if (!container) return false;

    try {
        osmd = new opensheetmusicdisplay.OpenSheetMusicDisplay(container, {
            autoResize: false, // ç”»é¢ã‚µã‚¤ã‚ºã«åˆã‚ã›ãŸè‡ªå‹•ãƒªã‚µã‚¤ã‚ºã‚’ç„¡åŠ¹åŒ–
            drawTitle: true,
            drawFingerings: false
        });
        
        // äº”ç·šè­œé–“ã®è·é›¢ã‚’130pxã«è¨­å®š
        osmd.EngravingRules.MinimumDistanceBetweenSystems = 12.0; // å˜ä½: 10px = 1.0
        osmd.EngravingRules.SystemDistance = 12.0;
        osmd.EngravingRules.StaffDistance = 12.0;
        
        osmd.zoom = 1.0;
        console.log("OSMDåˆæœŸåŒ–å®Œäº†");
        return true;
    } catch (e) {
        showError("åˆæœŸåŒ–ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: " + e.message);
        return false;
    }
}


// é‹æŒ‡è¨ˆç®—é–¢æ•°(æ¥½å™¨åˆ¥)
function calculateFingering(baseRatio, accType, instrument) {
    let finger = "?", color = "#000000";

    if (instrument === 'bass') {
        // ã‚³ãƒ³ãƒˆãƒ©ãƒã‚¹ã®é‹æŒ‡è¨ˆç®—
        if (baseRatio < -0.80) finger = "10"; else if (baseRatio < -0.65) finger = "9";
        else if (baseRatio < -0.50) finger = "7"; else if (baseRatio < -0.35) finger = "5";
        else if (baseRatio < -0.20) finger = "4"; else if (baseRatio < -0.05) finger = "2";
        else if (baseRatio < 0.10) finger = "0"; else if (baseRatio < 0.28) finger = "3";
        else if (baseRatio < 0.38) finger = "2"; else if (baseRatio < 0.48) finger = "0";
        else if (baseRatio < 0.78) finger = "3"; else if (baseRatio < 0.88) finger = "2";
        else if (baseRatio < 0.98) finger = "0"; else if (baseRatio < 1.18) finger = "3";
        else if (baseRatio < 1.38) finger = "1"; else finger = "0";
if (baseRatio < 0.10) color = "#2ecc71";
                else if (baseRatio < 0.48) color = "#3498db";
                else if (baseRatio < 0.98) color = "#e74c3c";
                else color = "#000000";
    } else {
        // ãƒã‚§ãƒ­ã®é‹æŒ‡è¨ˆç®—
	     if (baseRatio < -1.40) finger = "12"; else if (baseRatio < -1.25) finger = "11";
	else if (baseRatio < -1.10) finger = "9"; else if (baseRatio < -0.95) finger = "7";
	else if (baseRatio < -0.80) finger = "5"; else if (baseRatio < -0.65) finger = "4";
        else if (baseRatio < -0.50) finger = "2"; else if (baseRatio < -0.35) finger = "0";
        else if (baseRatio < -0.20) finger = "4"; else if (baseRatio < -0.05) finger = "2";
        else if (baseRatio < 0.10) finger = "0"; else if (baseRatio < 0.28) finger = "3";
        else if (baseRatio < 0.38) finger = "2"; else if (baseRatio < 0.48) finger = "0";
        else if (baseRatio < 0.78) finger = "3"; else if (baseRatio < 0.88) finger = "2";
        else if (baseRatio < 0.98) finger = "0"; 
if (baseRatio < -0.35) color = "#2ecc71";
    else if (baseRatio < 0.10) color = "#3498db";
    else if (baseRatio < 0.48) color = "#e74c3c";
    else color = "#000000";
    }

    

    if (finger !== "?" && !isNaN(finger)) {
        let fingerNum = parseInt(finger);
        if (accType === "sharp") { 
            fingerNum += 1; 
            finger = fingerNum.toString();
            // ãƒã‚§ãƒ­ã®å ´åˆ: é’4â†’ç·‘0ã¸ã®ç§»å‹•
            if (instrument === 'cello' && fingerNum === 5 && color === "#3498db") {
                finger = "0";
                color = "#2ecc71";
            }
        }
        else if (accType === "doublesharp") { 
            fingerNum += 2; 
            finger = fingerNum.toString();
            // ãƒã‚§ãƒ­ã®å ´åˆ: é’4â†’ç·‘0ã¸ã®ç§»å‹•ï¼ˆ+2ãªã®ã§ç›´æ¥0ã«ï¼‰
            if (instrument === 'cello' && fingerNum === 6 && color === "#3498db") {
                finger = "0";
                color = "#2ecc71";
            }
        }
        else if (accType === "flat") {
            if (fingerNum === 0) {
                finger = "4";
                // æ¥½å™¨åˆ¥ã®è‰²å¤‰æ›´å‡¦ç†
                if (instrument === 'bass') {
                    // ã‚³ãƒ³ãƒˆãƒ©ãƒã‚¹: å¼¦ç§»å‹•ã«ã‚ˆã‚‹è‰²å¤‰æ›´
		ã€€ã€€if (color === "#2ecc71") color = "#3498db";
                                    else if (color === "#3498db") color = "#e74c3c";
                                    else if (color === "#e74c3c") color = "#000000";
                } else {
                    // ãƒã‚§ãƒ­: å¼¦ç§»å‹•ã«ã‚ˆã‚‹è‰²å¤‰æ›´
                    if (color === "#2ecc71") color = "#3498db";
                    else if (color === "#3498db") color = "#e74c3c";
                    else if (color === "#e74c3c") color = "#000000";
                }
            } else { fingerNum -= 1; finger = fingerNum.toString(); }
        }
        else if (accType === "doubleflat") {
            if (fingerNum === 0) {
                finger = "3";
                // æ¥½å™¨åˆ¥ã®è‰²å¤‰æ›´å‡¦ç†
                if (instrument === 'bass') {
                    // ã‚³ãƒ³ãƒˆãƒ©ãƒã‚¹: è‰²å¤‰æ›´ãªã—
                } else {
                    // ãƒã‚§ãƒ­: å¼¦ç§»å‹•ã«ã‚ˆã‚‹è‰²å¤‰æ›´
                    if (color === "#2ecc71") color = "#3498db";
                    else if (color === "#3498db") color = "#e74c3c";
                    else if (color === "#e74c3c") color = "#000000";
                }
            } else if (fingerNum === 1) {
                finger = "4";
                // æ¥½å™¨åˆ¥ã®è‰²å¤‰æ›´å‡¦ç†
                if (instrument === 'bass') {
                    // ã‚³ãƒ³ãƒˆãƒ©ãƒã‚¹: è‰²å¤‰æ›´ãªã—
                } else {
                    // ãƒã‚§ãƒ­: å¼¦ç§»å‹•ã«ã‚ˆã‚‹è‰²å¤‰æ›´
                    if (color === "#2ecc71") color = "#3498db";
                    else if (color === "#3498db") color = "#e74c3c";
                    else if (color === "#e74c3c") color = "#000000";
                }
            } else if (fingerNum >= 2) {
                fingerNum -= 2;
                finger = fingerNum.toString();
            }
        }
    }

    return { finger, color };
}



        // æç”»ãƒªã‚»ãƒƒãƒˆé–¢æ•°
        function resetDrawings() {
            drawnClefs.clear();
            document.getElementById('finger-layer').innerHTML = "";
            
            // ãƒ‡ãƒãƒƒã‚°ãƒãƒ¼ã‚«ãƒ¼ã‚‚å‰Šé™¤
            const markers = document.querySelectorAll('.debug-marker, .debug-clef-marker');
            markers.forEach(marker => marker.remove());
        }

        // æ¥½å™¨é¸æŠãƒœã‚¿ãƒ³ã®è¨­å®š
        document.getElementById('cello-btn').onclick = function() {
            currentInstrument = 'cello';
            this.classList.add('active');
            document.getElementById('bass-btn').classList.remove('active');
            
            // æç”»ã‚’ãƒªã‚»ãƒƒãƒˆ
            resetDrawings();
            
            document.getElementById('status').innerText = "ãƒã‚§ãƒ­ãƒ¢ãƒ¼ãƒ‰ - é‹æŒ‡ã‚’è¡¨ç¤ºãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„";
        };

        document.getElementById('bass-btn').onclick = function() {
            currentInstrument = 'bass';
            this.classList.add('active');
            document.getElementById('cello-btn').classList.remove('active');
            
            // æç”»ã‚’ãƒªã‚»ãƒƒãƒˆ
            resetDrawings();
            
            document.getElementById('status').innerText = "ã‚³ãƒ³ãƒˆãƒ©ãƒã‚¹ãƒ¢ãƒ¼ãƒ‰ - é‹æŒ‡ã‚’è¡¨ç¤ºãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„";
        };

        // é‹æŒ‡è¨ˆç®—é–¢æ•°(æ¥½å™¨åˆ¥)
        function calculateFingering(baseRatio, accType, instrument) {
            let finger = "?", color = "#000000";

            if (instrument === 'bass') {
                // ã‚³ãƒ³ãƒˆãƒ©ãƒã‚¹ã®é‹æŒ‡è¨ˆç®—(å…ƒã®ã‚³ãƒ¼ãƒ‰)
                if (baseRatio < -0.80) finger = "10"; else if (baseRatio < -0.65) finger = "9";
                else if (baseRatio < -0.50) finger = "7"; else if (baseRatio < -0.35) finger = "5";
                else if (baseRatio < -0.20) finger = "4"; else if (baseRatio < -0.05) finger = "2";
                else if (baseRatio < 0.10) finger = "0"; else if (baseRatio < 0.28) finger = "3";
                else if (baseRatio < 0.38) finger = "2"; else if (baseRatio < 0.48) finger = "0";
                else if (baseRatio < 0.78) finger = "3"; else if (baseRatio < 0.88) finger = "2";
                else if (baseRatio < 0.98) finger = "0"; else if (baseRatio < 1.18) finger = "3";
                else if (baseRatio < 1.38) finger = "1"; else finger = "0";
if (baseRatio < 0.10) color = "#2ecc71";
            else if (baseRatio < 0.48) color = "#3498db";
            else if (baseRatio < 0.98) color = "#e74c3c";
            else color = "#000000";
            } else {
                // ãƒã‚§ãƒ­ã®é‹æŒ‡è¨ˆç®—
                // ãƒã‚§ãƒ­: 4å¼¦=A(ãƒ©), 3å¼¦=D(ãƒ¬), 2å¼¦=G(ã‚½), 1å¼¦=C(ãƒ‰)
                // baseRatio < 0.10 ãŒé–‹æ”¾å¼¦(ç·‘)ã€0.10-0.48ãŒæ¬¡ã®å¼¦(é’)ã€0.48-0.98ãŒæ¬¡(èµ¤)
                if (baseRatio < -1.40) finger = "12"; else if (baseRatio < -1.25) finger = "11";
	else if (baseRatio < -1.10) finger = "9"; else if (baseRatio < -0.95) finger = "7";
	else if (baseRatio < -0.80) finger = "5"; else if (baseRatio < -0.65) finger = "4";
        else if (baseRatio < -0.50) finger = "2"; else if (baseRatio < -0.35) finger = "0";
        else if (baseRatio < -0.20) finger = "4"; else if (baseRatio < -0.05) finger = "2";
        else if (baseRatio < 0.10) finger = "0"; else if (baseRatio < 0.28) finger = "3";
        else if (baseRatio < 0.38) finger = "2"; else if (baseRatio < 0.48) finger = "0";
        else if (baseRatio < 0.78) finger = "3"; else if (baseRatio < 0.88) finger = "2";
        else if (baseRatio < 0.98) finger = "0"; 
if (baseRatio < -0.35) color = "#2ecc71";
    else if (baseRatio < 0.10) color = "#3498db";
    else if (baseRatio < 0.48) color = "#e74c3c";
    else color = "#000000";
    }

            

            if (finger !== "?" && !isNaN(finger)) {
                let fingerNum = parseInt(finger);
                if (accType === "sharp") { fingerNum += 1; finger = fingerNum.toString(); }
                else if (accType === "doublesharp") { fingerNum += 2; finger = fingerNum.toString(); }
                else if (accType === "flat") {
                    if (fingerNum === 0) {
                        finger = "4";
                        if (color === "#2ecc71") color = "#3498db";
                        else if (color === "#3498db") color = "#e74c3c";
                        else if (color === "#e74c3c") color = "#000000";
                    } else { fingerNum -= 1; finger = fingerNum.toString(); }
                }
                else if (accType === "doubleflat") {
                    if (fingerNum === 0) {
                        finger = "3";
                        if (color === "#2ecc71") color = "#3498db";
                        else if (color === "#3498db") color = "#e74c3c";
                        else if (color === "#e74c3c") color = "#000000";
                    } else if (fingerNum === 1) {
                        finger = "4";
                        if (color === "#2ecc71") color = "#3498db";
                        else if (color === "#3498db") color = "#e74c3c";
                        else if (color === "#e74c3c") color = "#000000";
                    } else if (fingerNum >= 2) {
                        fingerNum -= 2;
                        finger = fingerNum.toString();
                    }
                }
            }

            return { finger, color };
        }

        document.getElementById('file-input').onchange = async (e) => {
            const file = e.target.files[0];
    if (!file) return;
    
    // ã‚¨ãƒ©ãƒ¼è¡¨ç¤ºã‚’ã‚¯ãƒªã‚¢
    const errDiv = document.getElementById('error-display');
    if (errDiv) errDiv.style.display = 'none';
    
    drawnClefs.clear();
    document.getElementById('finger-layer').innerHTML = "";
    
    const reader = new FileReader();
    reader.onload = async (ev) => {
        if (!osmd) {
            const success = await initOSMD();
            if (!success) return;
    }

            // å¤‰æ›´å¾Œ
    try {
                    await osmd.load(ev.target.result);
                    // 1è¡Œã®å°ç¯€æ•°ã‚’4ã«å›ºå®š
                    osmd.EngravingRules.MinMeasuresToDrawPerSystem = 4;
                    osmd.EngravingRules.MaxMeasuresToDrawPerSystem = 4;
                    
                    // æœ€å°è·é›¢åˆ¶é™ã‚’è§£é™¤(1.0)ã—ã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’70px(7.0)ã«ã™ã‚‹
                    osmd.EngravingRules.MinimumDistanceBetweenSystems = 1.0;
                    osmd.EngravingRules.SystemDistance = 7.0;
                    osmd.EngravingRules.StaffDistance = 7.0;
                    
                    // æ¥½è­œè‡ªä½“ã®ã‚ºãƒ¼ãƒ ã€‚ãƒœã‚¿ãƒ³(controls)ã¯ç‹¬ç«‹ã—ã¦ã„ã‚‹ãŸã‚å½±éŸ¿ã‚’å—ã‘ã¾ã›ã‚“
                    osmd.zoom = 1.0; 
                    osmd.render();
                    setTimeout(() => {
        document.getElementById('finger-layer').style.height = document.getElementById('score-container').offsetHeight + "px";
        const instName = currentInstrument === 'cello' ? 'ãƒã‚§ãƒ­' : 'ã‚³ãƒ³ãƒˆãƒ©ãƒã‚¹';
        document.getElementById('status').innerText = `æº–å‚™å®Œäº†ã€‚${instName}ãƒ¢ãƒ¼ãƒ‰`;
    }, 1000);
    console.log("æç”»ã«æˆåŠŸã—ã¾ã—ãŸ");
} catch (error) {
    showError("æ¥½è­œã®è§£æã‚¨ãƒ©ãƒ¼: MusicXMLãƒ•ã‚¡ã‚¤ãƒ«ãŒæ­£ã—ããªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚\n" + error.message);
}
            };
            reader.readAsText(file);
        };

        document.getElementById('scan-btn').onclick = async function() {
            const accBtn = document.getElementById('toggle-acc-btn');
            const keyBtn = document.getElementById('toggle-key-btn');
            accBtn.disabled = true;
            keyBtn.disabled = true;
            
            document.getElementById('input-blocker').style.display = 'block'; // ã‚¿ãƒƒãƒ/ã‚¯ãƒªãƒƒã‚¯ã‚’ãƒ–ãƒ­ãƒƒã‚¯
            document.body.style.overflow = 'hidden'; // â˜†ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’å®Œå…¨ã«ç¦æ­¢
            
            const score = document.getElementById('score-container');
            const svgLayer = document.getElementById('finger-layer');
            const processedClefs = new Set(); // å‡¦ç†æ¸ˆã¿ã®äº”ç·šè­œã‚’è¨˜éŒ²ï¼ˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æ™‚ã®é‡è¤‡é˜²æ­¢ï¼‰

            // è‡ªå‹•ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é–‹å§‹ï¼šã¾ãšã¯æœ€ä¸Šéƒ¨ã¸
            window.scrollTo(0, 0);
            await new Promise(r => setTimeout(r, 600)); 

            const scanLine = document.getElementById('scan-line');
            scanLine.style.display = 'block';

            // --- åˆæœŸæ¼”å‡º: ä¸Šã‹ã‚‰ä¸‹ã¸ (1.5ç§’ã‹ã‘ã¦ã‚†ã£ãã‚Š) ---
            scanLine.style.transition = 'top 0.3s ease-in-out';
            scanLine.style.top = '100%';
            await new Promise(r => setTimeout(r, 1600));

            // --- åˆæœŸæ¼”å‡º: ä¸‹ã‹ã‚‰ä¸Šã¸ (0.8ç§’ã§æ»‘ã‚‰ã‹ã«æˆ»ã‚‹) ---
            scanLine.style.transition = 'top 0.3s ease-in-out';
            scanLine.style.top = '0%';
            await new Promise(r => setTimeout(r, 900));

	    // --- åˆæœŸæ¼”å‡º: ä¸Šã‹ã‚‰ä¸‹ã¸ (1.5ç§’ã‹ã‘ã¦ã‚†ã£ãã‚Š) ---
            scanLine.style.transition = 'top 1.3s ease-in-out';
            scanLine.style.top = '100%';
            await new Promise(r => setTimeout(r, 1600));

            while (true) {
                // 1. ã‚¹ã‚­ãƒ£ãƒ³ã®é–‹å§‹:ãƒ©ã‚¤ãƒ³ã‚’çœŸä¸Šã«ãƒªã‚»ãƒƒãƒˆ
                scanLine.style.transition = 'none';
                scanLine.style.top = '0%';
                scanLine.style.opacity = '1';
                // ãƒªã‚»ãƒƒãƒˆã‚’åæ˜ ã•ã›ã‚‹ãŸã‚ã®çŸ­ã„å¾…ã¡
                await new Promise(r => setTimeout(r, 50));
                const scoreRect = score.getBoundingClientRect();
                const viewTop = window.scrollY;
                const viewBottom = viewTop + window.innerHeight;
                const currentPassClefs = new Set(); // ä»Šå›ã®ç”»é¢ã§è¦‹ãˆã¦ã„ã‚‹äº”ç·šè­œ

                // svgLayer.innerHTML = ""; // ã“ã®è¡Œã‚’å‰Šé™¤ï¼ˆæç”»æ¸ˆã¿è¦ç´ ã‚’ä¿æŒï¼‰

                const allPaths = Array.from(score.querySelectorAll("path"));
            const allGraphics = Array.from(score.querySelectorAll("path, rect"))
                .sort((a, b) => a.getBoundingClientRect().left - b.getBoundingClientRect().left);

            const clefs = allPaths.filter(p => {
                    const r = p.getBoundingClientRect();
                    // ã‚µã‚¤ã‚ºãƒã‚§ãƒƒã‚¯
                    if (r.height < 20 || r.height > 70 || r.width < 15 || r.width > 55) return false;
                    
                    // ã¸éŸ³è¨˜å·ã®ç¸¦æ¨ªæ¯”ãƒã‚§ãƒƒã‚¯ï¼ˆç¸¦é•·ã®è¨˜å·ã®ã¿ï¼‰
                    const aspectRatio = r.height / r.width;
                    return aspectRatio >= 1.1 && aspectRatio <= 1.5;
                }).map(c => {
                const r = c.getBoundingClientRect();
                return { top: r.top + window.scrollY, height: r.height, left: r.left };
            }).filter((clef, index, self) => 
                index === self.findIndex((t) => Math.abs(t.top - clef.top) < 5)
            );

// === [DEBUG SCOPE: Staff Measurement] START ===
if (clefs && clefs.length > 0) {
    clefs.forEach((clef, index) => {
        const staffHeight = clef.height;
        let logMsg = `[äº”ç·šè­œ ${index + 1}] é«˜ã•: ${staffHeight.toFixed(2)}px`;
        if (index < clefs.length - 1) {
            const nextClef = clefs[index + 1];
            const gap = nextClef.top - (clef.top + staffHeight);
            logMsg += ` | é–“éš”: ${gap.toFixed(2)}px`;
        }
        console.log(logMsg);
    });
}
// === [DEBUG SCOPE: Staff Measurement] END ===

            // äº”ç·šè­œãŒç”»é¢å†…ã«å®Œå…¨ã«åã¾ã£ã¦ã„ã‚‹ã‹åˆ¤å®šã™ã‚‹é–¢æ•°
            function isStaffFullyVisible(clef) {
                const staffMargin = clef.height * 1.5; // äº”ç·šè­œã®ä¸Šä¸‹30pxç¨‹åº¦ã®ä½™è£•
                const staffTop = clef.top - staffMargin;
                const staffBottom = clef.top + clef.height + staffMargin;
                
                // ç”»é¢å†…åˆ¤å®š
                if (staffTop < viewTop || staffBottom > viewBottom) return false;

                // é‡è¤‡åˆ¤å®šï¼šçµ¶å¯¾ä½ç½®(scrollYè¾¼ã¿)ã§ãƒ¦ãƒ‹ãƒ¼ã‚¯IDã‚’ä½œæˆã—ã¦ãƒã‚§ãƒƒã‚¯
                const clefAbsKey = (clef.top + window.scrollY).toFixed(1);
                if (processedClefs.has(clefAbsKey)) return false; // ä»¥å‰ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã§å‡¦ç†æ¸ˆã¿ãªã‚‰ã‚¹ã‚­ãƒƒãƒ—
                
                currentPassClefs.add(clefAbsKey); // ä»Šå›å‡¦ç†å¯¾è±¡ã¨ã—ã¦ãƒãƒ¼ã‚¯
                return true;
            }

            // 2. ã‚¹ã‚­ãƒ£ãƒ³å®Ÿè¡Œ:è¦‹ãˆã¦ã„ã‚‹ä¸€ç•ªä¸‹ã®äº”ç·šè­œã®ç›´å¾Œã¾ã§å‹•ã‹ã™
            const visibleClefs = clefs.filter(c => isStaffFullyVisible(c));
            if (visibleClefs.length > 0) {
                const lastClef = visibleClefs[visibleClefs.length - 1];
                const targetY = (lastClef.top + lastClef.height + 20) - window.scrollY;
                
                // â˜†è¿½åŠ : ã‚¹ã‚­ãƒ£ãƒ³ãƒ©ã‚¤ãƒ³ç§»å‹•é–‹å§‹å‰ã®ã€Œæºœã‚ã€æ¼”å‡º (400mså¾…æ©Ÿ)
                await new Promise(r => setTimeout(r, 400));
                
                // æ»‘ã‚‰ã‹ã«ä¸‹ã¸ç§»å‹•(è§£æé€Ÿåº¦ã«åˆã‚ã›ã¦1.3ç§’ã«å¾®å¢—)
                scanLine.style.transition = 'top 1.3s ease-in-out';
                scanLine.style.top = targetY + 'px';
            }

            const heads = Array.from(score.querySelectorAll(".vf-notehead, ellipse, path")).filter(el => {
                const r = el.getBoundingClientRect();
                const isCorrectSize = r.width > 8 && r.width < 22 && r.height > 5 && r.height < 18;
                const isNoteClass = el.classList.contains('vf-notehead') || el.tagName === 'ellipse';
                const isInsideNote = el.closest('.vf-note') !== null;
                return isCorrectSize && (isNoteClass || isInsideNote);
            });

            const accidentals = allPaths.filter(p => {
                const r = p.getBoundingClientRect();
                const isAccSize = r.height > 10 && r.height < 45 && r.width > 4 && r.width < 25;
                if (!isAccSize) return false;
                const ratio = r.height / r.width;
                console.log(`è‡¨æ™‚è¨˜å·å€™è£œ: é«˜ã•=${r.height.toFixed(2)}, å¹…=${r.width.toFixed(2)}, ç¸¦æ¨ªæ¯”=${ratio.toFixed(3)}`);
                if (ratio < 0.6) return false; // ãƒ€ãƒ–ãƒ«ã‚·ãƒ£ãƒ¼ãƒ—æ¤œå‡ºã®ãŸã‚ç¯„å›²ã‚’æ‹¡å¼µ
                if (ratio > 3.36 && ratio < 3.42) return false; 
                const pTop = r.top + window.scrollY;
                let isOverlapNoteX = false;
                const targetClef = clefs.reduce((prev, curr) => 
                    Math.abs(curr.top - pTop) < Math.abs(prev.top - pTop) ? curr : prev
                , clefs[0]);
                if (targetClef) {
                    heads.forEach(h => {
                        const hRect = h.getBoundingClientRect();
                        const hTop = hRect.top + window.scrollY;
                        const isSameStaff = Math.abs(hTop - targetClef.top) < 60;
                        if (isSameStaff) {
                            const overlapX = r.left < hRect.right - 2 && r.right > hRect.left + 2;
                            if (overlapX) isOverlapNoteX = true;
                        }
                    });
                }
                return !isOverlapNoteX; 
            });

            const activeAccidentals = [];
            let accidentalCounter = 1;

            // ========== ç¬¬1æ®µéš: è‡¨æ™‚è¨˜å·ã«ã‚ˆã‚‹é‹æŒ‡è¨ˆç®— ==========
            heads.forEach(head => {
                const r = head.getBoundingClientRect();
                const noteTop = r.top + window.scrollY;

                const myClef = clefs.reduce((prev, curr) => 
                    Math.abs(curr.top - noteTop) < Math.abs(prev.top - noteTop) ? curr : prev
                , clefs[0]);
                if (!myClef || !isStaffFullyVisible(myClef)) return;
                
                // æç”»æ¸ˆã¿ã‚¯ãƒ¬ãƒ•ã®äº”ç·šè­œã¯ã‚¹ã‚­ãƒƒãƒ—
                const clefKey = myClef.top.toFixed(1);
                if (drawnClefs.has(clefKey)) return;

                let accType = "none";
                let searchAreaH = 12; 
                let searchAreaY = (r.top + (r.height / 2)) - (searchAreaH / 2) - scoreRect.top;

                accidentals.forEach(acc => {
                    const aRect = acc.getBoundingClientRect();
                    const isLeftNear = (r.left - aRect.right > -2) && (r.left - aRect.right < 10);
                    const accCenterY = aRect.top - scoreRect.top + (aRect.height / 2);
                    const isNearY = Math.abs(accCenterY - (searchAreaY + searchAreaH/2)) < (searchAreaH / 2 + 2);
                    
                    if (isLeftNear && isNearY) {
                        const ratio = aRect.height / aRect.width;
                        console.log(`éŸ³ç¬¦è¿‘å‚ã®è‡¨æ™‚è¨˜å·: ç¸¦æ¨ªæ¯”=${ratio.toFixed(3)}`);
                        let currentAcc = "none";
                        if (ratio >= 1.6 && ratio <= 1.9) currentAcc = "doubleflat";
                        else if (ratio >= 3.6) currentAcc = "natural";
                        else if (ratio >= 3.25 && ratio <= 3.35) currentAcc = "sharp";
                        else if (ratio >= 3.1 && ratio <= 3.24) currentAcc = "flat";
                        else if (ratio >= 0.85 && ratio <= 1.4) currentAcc = "doublesharp";

                        if (currentAcc !== "none") {
                            // const accKey = `${aRect.left.toFixed(1)},${aRect.top.toFixed(1)}`;
                            
                            
                            let barlineX = aRect.right + 800;
                            allGraphics.forEach(p => {
                                const pRect = p.getBoundingClientRect();
                                const isVertical = pRect.height > 30 && pRect.width < 4;
                                const isSameStaff = Math.abs(pRect.top + window.scrollY - myClef.top) < 120;
                                if (isVertical && isSameStaff && pRect.left > aRect.right && pRect.left < barlineX) {
                                    let isStem = false;
                                    heads.forEach(h => {
                                        const hRect = h.getBoundingClientRect();
                                        const isOverlapX = pRect.left >= hRect.left - 2 && pRect.left <= hRect.right + 2;
                                        const isOverlapY = hRect.bottom > pRect.top - 5 && hRect.top < pRect.bottom + 5;
                                        if (isOverlapX && isOverlapY) isStem = true;
                                    });
                                    if (!isStem) barlineX = pRect.left;
                                }
                            });

                            activeAccidentals.push({
                                type: currentAcc,
                                left: aRect.left,
                                right: barlineX,
                                top: r.top,
                                id: accidentalCounter,
                                color: currentAcc === "doubleflat" ? "#9b59b6" :
                                       currentAcc === "natural" ? "#2ecc71" : 
                                       currentAcc === "sharp" ? "#e74c3c" : 
                                       currentAcc === "doublesharp" ? "#f39c12" : "#3498db"
                            });
                            
                            // drawnElements.accidentals.add(accKey);

                            // è‡¨æ™‚è¨˜å·ç•ªå·ã®è¡¨ç¤º
                            const accNumTxt = document.createElementNS("http://www.w3.org/2000/svg", "text");
                            accNumTxt.setAttribute("x", aRect.left - scoreRect.left - 5);
                            accNumTxt.setAttribute("y", aRect.top - scoreRect.top - 5);
                            accNumTxt.setAttribute("fill", "#000");
                            accNumTxt.setAttribute("font-size", "14px");
                            accNumTxt.setAttribute("font-weight", "bold");
                            accNumTxt.setAttribute("class", "guide-accidental");
                            accNumTxt.textContent = accidentalCounter;
                            svgLayer.appendChild(accNumTxt);

                            // è‡¨æ™‚è¨˜å·ã®æ å›²ã¿
                            const accBox = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                            accBox.setAttribute("x", aRect.left - scoreRect.left - 2);
                            accBox.setAttribute("y", aRect.top - scoreRect.top - 2);
                            accBox.setAttribute("width", aRect.width + 4);
                            accBox.setAttribute("height", aRect.height + 4);
                            accBox.setAttribute("fill", "none");
                            accBox.setAttribute("stroke", activeAccidentals[activeAccidentals.length - 1].color);
                            accBox.setAttribute("stroke-width", "2");
                            accBox.setAttribute("class", "guide-accidental");
                            svgLayer.appendChild(accBox);

                            // å½±éŸ¿ç¯„å›²ã®è¡¨ç¤º
                            const areaRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                            areaRect.setAttribute("x", aRect.left - scoreRect.left);
                            areaRect.setAttribute("y", searchAreaY);
                            areaRect.setAttribute("width", barlineX - aRect.left);
                            areaRect.setAttribute("height", searchAreaH);
                            let rgba = currentAcc === "doubleflat" ? "rgba(155, 89, 182, 0.15)" :
                                       currentAcc === "natural" ? "rgba(39, 174, 96, 0.15)" : 
                                       currentAcc === "sharp" ? "rgba(231, 76, 60, 0.15)" : 
                                       currentAcc === "doublesharp" ? "rgba(243, 156, 18, 0.15)" : "rgba(52, 152, 219, 0.15)";
                            areaRect.setAttribute("fill", rgba);
                            areaRect.setAttribute("stroke", activeAccidentals[activeAccidentals.length - 1].color);
                            areaRect.setAttribute("stroke-width", "1");
                            areaRect.setAttribute("stroke-dasharray", "2,2");
                            areaRect.setAttribute("class", "guide-accidental");
                            svgLayer.appendChild(areaRect);

                            accidentalCounter++;
                        }
                    }
                });

                // å„ªå…ˆé †ä½ãƒ­ã‚¸ãƒƒã‚¯: è¤‡æ•°ã®è‡¨æ™‚è¨˜å·ãŒé‡ãªã‚‹å ´åˆã¯æœ€ã‚‚å³å´ã‚’å„ªå…ˆ
                const overlappingEffects = activeAccidentals.filter(a => 
                    r.left >= a.left && r.left <= a.right && Math.abs(r.top - a.top) < 5
                );

                if (overlappingEffects.length > 0) {
                    const priorityEffect = overlappingEffects.reduce((prev, curr) => 
                        (curr.left > prev.left) ? curr : prev
                    );
                    accType = priorityEffect.type;
                }

                const baseRatio = (noteTop - myClef.top) / myClef.height;
                    const result = calculateFingering(baseRatio, accType, currentInstrument);

                    const relX = r.left - scoreRect.left + (r.width / 2);
                const relY = r.top - scoreRect.top;
                const txt = document.createElementNS("http://www.w3.org/2000/svg", "text");
            		    txt.setAttribute("x", relX);
                	    txt.setAttribute("y", relY + 30);
                	    txt.setAttribute("fill", result.color);
                	    txt.setAttribute("font-size", "18px");
                	    txt.setAttribute("font-weight", "bold");
                	    txt.setAttribute("text-anchor", "middle");
                	    txt.setAttribute("class", "finger-label"); 
                	    txt.textContent = result.finger;
                	    svgLayer.appendChild(txt);
                
                // drawnElements.notes.add(noteKey); (å‰Šé™¤)
                // å½±éŸ¿ã‚’å—ã‘ãŸéŸ³ç¬¦ã®æ å›²ã¿
                if (accType !== "none" && overlappingEffects.length > 0) {
                    const noteBox = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    noteBox.setAttribute("x", r.left - scoreRect.left - 2);
                    noteBox.setAttribute("y", r.top - scoreRect.top - 2);
                    // æ ã®ã‚µã‚¤ã‚ºã‚’éŸ³ç¬¦æœ¬ä½“ã®ã¿ã«åˆ¶é™ï¼ˆæœ€å¤§å¹…14pxã€æœ€å¤§é«˜ã•12pxï¼‰
                    noteBox.setAttribute("width", Math.min(r.width + 4, 14));
                    noteBox.setAttribute("height", Math.min(r.height + 4, 12));
                    noteBox.setAttribute("fill", "none");
                    noteBox.setAttribute("stroke", overlappingEffects[overlappingEffects.length - 1].color);
                    noteBox.setAttribute("stroke-width", "2");
                    noteBox.setAttribute("class", "guide-accidental");
                    svgLayer.appendChild(noteBox);


                    // å‚ç…§ç•ªå·ã®è¡¨ç¤º
                    const refAcc = overlappingEffects.reduce((prev, curr) => (curr.left > prev.left) ? curr : prev);
                    const refNumTxt = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    refNumTxt.setAttribute("x", r.left - scoreRect.left + (r.width / 2) + 12);
                    refNumTxt.setAttribute("y", r.top - scoreRect.top + 15);
                    refNumTxt.setAttribute("fill", "#7f8c8d");
                    refNumTxt.setAttribute("font-size", "10px");
                    refNumTxt.setAttribute("class", "guide-accidental");
                    refNumTxt.textContent = "(" + refAcc.id + ")";
                    svgLayer.appendChild(refNumTxt);
                }
            });



            // ========== ç¬¬2æ®µéš: èª¿å·ã®æ¤œå‡ºã¨ã‚¬ã‚¤ãƒ‰ç·šæç”» ==========
            const extendedKeySigs = [];
            let clefSigCounter = 1; // â˜…ä¿®æ­£: ã“ã“ã§å¤‰æ•°ã‚’å®šç¾©ãƒ»åˆæœŸåŒ–ã—ã¾ã™
	    let sigCenterX = 1;
            // ã‚¯ãƒ¬ãƒ•ç›´å¾Œã®èª¿å·
            clefs.forEach(c => {
                if (!isStaffFullyVisible(c)) return;

		// æç”»æ¸ˆã¿ã‚¯ãƒ¬ãƒ•ã¯ã‚¹ã‚­ãƒƒãƒ—
                const clefKey = c.top.toFixed(1);
                if (drawnClefs.has(clefKey)) return;
                const cR = score.querySelectorAll("path")[allPaths.indexOf(allPaths.find(p => p.getBoundingClientRect().left === c.left))].getBoundingClientRect();
                const staffSigs = accidentals.filter(acc => {
                    const aR = acc.getBoundingClientRect();
                    return aR.left > cR.right - 5 && aR.left < cR.right + 40 && Math.abs(aR.top + window.scrollY - c.top) < 60;
                });
                
                staffSigs.forEach(sig => {
                    // éŸ³ç¬¦ã¨ã®é‡ãªã‚Šãƒã‚§ãƒƒã‚¯ï¼ˆå³æ ¼ç‰ˆï¼‰
                    const sR = sig.getBoundingClientRect();
                    let isOverlapWithNote = false;

                    // â˜…è¿½åŠ : è¨˜å·ã®ç¨®é¡ã‚’å…ˆã«åˆ¤å®š
                    const ratio = sR.height / sR.width;
                    let sigType = "none";
                    if (ratio >= 3.25 && ratio <= 3.44) sigType = "sharp";
                    else if (ratio >= 2.8 && ratio <= 3.24) sigType = "flat";
                    // naturalã¯é€šå¸¸ã‚¯ãƒ¬ãƒ•ç›´å¾Œã«ã¯æ¥ãªã„ãŒã€å¿µã®ãŸã‚è¿½åŠ 
                    else if (ratio >= 3.45) sigType = "natural";
                    
                    // â˜…ä¿®æ­£: è¨˜å·ã®åŸºæº–é«˜ã•ã‚’è¨ˆç®—ï¼ˆã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³æç”»ã¨åŒã˜ä½ç½®ï¼‰
                    let yOffsetRatio = (sigType === "flat") ? 0.78 : (sigType === "natural" ? 0.5 : 0.55);
                    let sigReferenceY = sR.top + (sR.height * yOffsetRatio);

                                       // â˜…ãƒ‡ãƒãƒƒã‚°: è¨˜å·å…¨ä½“ã®æ 
                    const debugBox = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    
                    // â˜…ãƒ‡ãƒãƒƒã‚°: åŸºæº–é«˜ã•ã®ç·šï¼ˆèµ¤ã„æ¨ªç·šï¼‰
                    const refLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    
                    // â˜…ãƒ‡ãƒãƒƒã‚°: åŸºæº–é«˜ã•Â±5pxã®ç¯„å›²ï¼ˆè–„ã„èµ¤ï¼‰
                    const refRange = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                         
                    // â˜…ãƒ‡ãƒãƒƒã‚°: å³å´æ¤œå‡ºç¯„å›²ï¼ˆç·‘ï¼‰
                    const rightRange = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                        
                    // â˜…è¿½åŠ : è¨˜å·ã®ä¸­å¿ƒXåº§æ¨™ã‚’è¨ˆç®—
                    const sigCenterX = sR.left + (sR.width / 2);
                    
                    let debugInfo = {
                        id: `C${clefSigCounter}`,
                        type: sigType,
                        sigTop: sR.top.toFixed(1),
                        sigHeight: sR.height.toFixed(1),
                        sigLeft: sR.left.toFixed(1),
                        sigWidth: sR.width.toFixed(1),
                        sigCenterX: sigCenterX.toFixed(1),
                        yOffsetRatio: yOffsetRatio,
                        referenceY: sigReferenceY.toFixed(1),
                        nearNotes: []
                    };
                    
                    let noteCounter = 1;

                    heads.forEach(h => {
                        const hRect = h.getBoundingClientRect();
                        const hTop = hRect.top + window.scrollY;
                        const isSameStaff = Math.abs(hTop - c.top) < 60;
                        if (isSameStaff) {
                            // â˜…ä¿®æ­£: å³å´ã«éŸ³ç¬¦ãŒã‚ã‚Šã€ã‹ã¤åŸºæº–é«˜ã•ãŒåŒã˜å ´åˆã«è‡¨æ™‚è¨˜å·ã¨åˆ¤å®š

                            // â˜…è¿½åŠ : éŸ³ç¬¦ã®ä¸­å¿ƒXåº§æ¨™
                            const noteCenterX = hRect.left + (hRect.width / 2);
                            const distanceX = noteCenterX - sigCenterX;

                            const distance = hRect.left - sR.right;
                            const heightDiff = hRect.top - sigReferenceY;
                            
                            // â˜…ä¿®æ­£: å³å´ã®è·é›¢ï¼ˆä¸­å¿ƒé–“ï¼‰ãŒ23pxæœªæº€
                            const isCloseInX = distanceX > 0 && distanceX < 23.0;
                            
                            // â˜…è¿½åŠ : å·¦å´ã®è·é›¢ã‚‚ç¢ºèªï¼ˆ8åˆ†éŸ³ç¬¦ã®æ——å¯¾ç­–ï¼‰
                            const distanceNegX = sigCenterX - noteCenterX;
                            const isCloseInNegX = distanceNegX > 0 && distanceNegX < 10.0;
                            
                            // é«˜ã•åˆ¤å®šã¯å‚è€ƒå€¤ã¨ã—ã¦æ®‹ã™ãŒã€åˆ¤å®šã«ã¯ä½¿ã‚ãªã„
                            const isSameHeight = Math.abs(hRect.top - sigReferenceY) < 1.3;
                            const isNoteOnRight = hRect.left > sR.right - 5 && hRect.left < sR.right + 15;
                            
                            // è¿‘æ¥éŸ³ç¬¦ã®ã¿è¨˜éŒ²
                            if (Math.abs(distance) < 50 || isCloseInX || isCloseInNegX) {
                                debugInfo.nearNotes.push({
                                    noteNum: noteCounter,
                                    noteLeft: hRect.left.toFixed(1),
                                    noteTop: hRect.top.toFixed(1),
                                    noteCenterX: noteCenterX.toFixed(1),
                                    sigCenterX: sigCenterX.toFixed(1),
                                    distanceX: distanceX.toFixed(1),
                                    distanceNegX: distanceNegX.toFixed(1),
                                    distance: distance.toFixed(1),
                                    heightDiff: heightDiff.toFixed(1),
                                    isNoteOnRight: isNoteOnRight,
                                    isSameHeight: isSameHeight,
                                    isCloseInX: isCloseInX,
                                    isCloseInNegX: isCloseInNegX,
                                    willTrigger: isCloseInX || isCloseInNegX
                                });
                                
                                // â˜…ãƒ‡ãƒãƒƒã‚°: éŸ³ç¬¦ä½ç½®ãƒãƒ¼ã‚«ãƒ¼
                                const noteMarker = document.createElementNS("http://www.w3.org/2000/svg", "circle");

                               // â˜…ãƒ‡ãƒãƒƒã‚°: éŸ³ç¬¦ç•ªå·
                                const noteLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
                            }
                            
                            // â˜…ä¿®æ­£: Xåº§æ¨™è¿‘æ¥åˆ¤å®šï¼ˆå³å´ã¾ãŸã¯å·¦å´ï¼‰
                            if (isCloseInX || isCloseInNegX) {
                                isOverlapWithNote = true;
                                // â˜…ãƒ‡ãƒãƒƒã‚°: ãƒãƒƒãƒã—ãŸç·š
                                const matchLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
			    }
                        }
                    });

                    console.log(`%c[${debugInfo.id}]`, 'color: blue; font-weight: bold; font-size: 16px;',
                        `åˆ¤å®š: ${isOverlapWithNote ? 'ğŸš« è‡¨æ™‚è¨˜å·(ã‚¹ã‚­ãƒƒãƒ—)' : 'âœ… èª¿å·(å‡¦ç†)'}`,
                        `\nè¨˜å·ã‚¿ã‚¤ãƒ—: ${debugInfo.type}`,
                        `\nè¨˜å·ä½ç½®: top=${debugInfo.sigTop}, left=${debugInfo.sigLeft}, width=${debugInfo.sigWidth}`,
                        `\nè¨˜å·ä¸­å¿ƒX: ${debugInfo.sigCenterX}`,
                        `\nyOffsetRatio: ${debugInfo.yOffsetRatio}`,
                        `\nåŸºæº–é«˜ã•: ${debugInfo.referenceY}`,
                        `\nè¿‘æ¥éŸ³ç¬¦:`, debugInfo.nearNotes);
                    
                    clefSigCounter++;


                    if (isOverlapWithNote) return; // éŸ³ç¬¦ã¨é‡ãªã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
                    console.log(`ã‚¯ãƒ¬ãƒ•ç›´å¾Œã®èª¿å·: ç¸¦æ¨ªæ¯”=${ratio.toFixed(3)}, ã‚¿ã‚¤ãƒ—åˆ¤å®š=${(ratio >= 3.25 && ratio <= 3.44) ? "sharp" : (ratio >= 2.8 && ratio <= 3.24) ? "flat" : "none"}`);
                    let type = (ratio >= 3.25 && ratio <= 3.44) ? "sharp" : (ratio >= 2.8 && ratio <= 3.24) ? "flat" : "none";
                    
                    if (type !== "none") {
                        let yOffsetRatio = (type === "flat") ? 0.78 : 0.55;
                        let baseAdjustedY = sR.top - scoreRect.top + (sR.height * yOffsetRatio) - 1;
                        const startX = sR.left - scoreRect.left;

                        extendedKeySigs.push({ type, y: baseAdjustedY, clef: c, left: sR.left });
                        
                        // const keySigKey... (å‰Šé™¤)
                        
                        // æç”» (æ¡ä»¶åˆ†å²ãªã—ã§å®Ÿè¡Œ)
                        let line1 = drawGuideLine(svgLayer, baseAdjustedY, scoreRect.width, "rgba(255, 0, 255, 0.8)", "1", startX);
                        if(line1) line1.setAttribute("class", "guide-keysig");

                        [-1, 1].forEach(octave => {
                            let octY = baseAdjustedY - (c.height * 1.10 * octave);
                            extendedKeySigs.push({ type, y: octY, clef: c, left: sR.left });
                            // æç”»
                            let line2 = drawGuideLine(svgLayer, octY, scoreRect.width, "rgba(255, 0, 255, 0.4)", "0.5", startX);
                            if(line2) line2.setAttribute("class", "guide-keysig");
                        });
                        
                        // drawnElements.keySigs.add(keySigKey); (å‰Šé™¤)
                        
                        const pinkBox = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                        pinkBox.setAttribute("x", sR.left - scoreRect.left - 2);
                        pinkBox.setAttribute("y", sR.top - scoreRect.top - 2);
                        pinkBox.setAttribute("width", sR.width + 4);
                        pinkBox.setAttribute("height", sR.height + 4);
                        pinkBox.setAttribute("fill", "none");
                        pinkBox.setAttribute("stroke", "#ff00ff");
                        pinkBox.setAttribute("stroke-width", "2");
                        pinkBox.setAttribute("class", "guide-keysig");
                        svgLayer.appendChild(pinkBox);
                    }
                });
            });

            // è­œä¸­ã®èª¿å·
            let midSigCounter = 1; // â˜…ä¿®æ­£: ã“ã“ã§å¤‰æ•°ã‚’å®šç¾©ãƒ»åˆæœŸåŒ–ã—ã¾ã™
            accidentals.forEach(acc => {
                const aR = acc.getBoundingClientRect();
                
                const aTop = aR.top + window.scrollY;
                const myC = clefs.reduce((p, c) => Math.abs(c.top - aTop) < Math.abs(p.top - aTop) ? c : p, clefs[0]);
                if (!myC || !isStaffFullyVisible(myC)) return;
                
                // æç”»æ¸ˆã¿ã‚¯ãƒ¬ãƒ•ã¯ã‚¹ã‚­ãƒƒãƒ—
                const clefKey = myC.top.toFixed(1);
                if (drawnClefs.has(clefKey)) return;
                
                const isAlreadyUsedAsLocal = activeAccidentals.some(a => Math.abs(a.left - aR.left) < 2);
                if (isAlreadyUsedAsLocal) return;
                
                const isAlreadyProcessed = aR.left < myC.left + 75;
                if (isAlreadyProcessed) return;

                let nearestBarline = null;
                allGraphics.forEach(p => {
                    const pRect = p.getBoundingClientRect();
                    const isVertical = pRect.height > 30 && pRect.width < 4;
                    const isSameStaff = Math.abs(pRect.top + window.scrollY - myC.top) < 20;
                    if (isVertical && isSameStaff && pRect.left < aR.left) {
                        if (!nearestBarline || pRect.left > nearestBarline.left) {
                            nearestBarline = pRect;
                        }
                    }
                });

                if (nearestBarline && (aR.left - nearestBarline.right < 40)) {



                    // éŸ³ç¬¦ã¨ã®è¿‘å‚ãƒã‚§ãƒƒã‚¯ï¼ˆéŸ³ç¬¦ã®å·¦å³15pxä»¥å†…ã‚’é™¤å¤–ï¼‰
                    let isTooCloseToNote = false;
                    const aTop = aR.top + window.scrollY;
                    
                    // â˜…è¿½åŠ : è¨˜å·ã®ç¨®é¡ã‚’å…ˆã«åˆ¤å®š
                    const ratio2 = aR.height / aR.width;
                    let sigType2 = "none";
                    if (ratio2 >= 3.45) sigType2 = "natural";
                    else if (ratio2 >= 3.25 && ratio2 <= 3.44) sigType2 = "sharp";
                    else if (ratio2 >= 3.1 && ratio2 <= 3.24) sigType2 = "flat";
                    
                    // â˜…è¿½åŠ : è¨˜å·ã®åŸºæº–é«˜ã•ã‚’è¨ˆç®—ï¼ˆã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³æç”»ã¨åŒã˜ä½ç½®ï¼‰
                    let yOffsetRatio2 = (sigType2 === "flat") ? 0.78 : (sigType2 === "natural" ? 0.5 : 0.55);
                    let sigReferenceY2 = aR.top + (aR.height * yOffsetRatio2);

		    // â˜…ãƒ‡ãƒãƒƒã‚°: è¨˜å·ç•ªå·ãƒ©ãƒ™ãƒ«
                    const debugLabel2 = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    
                    // â˜…ãƒ‡ãƒãƒƒã‚°: è¨˜å·å…¨ä½“ã®æ 
                    const debugBox2 = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    
                    // â˜…ãƒ‡ãƒãƒƒã‚°: åŸºæº–é«˜ã•ã®ç·šï¼ˆã‚ªãƒ¬ãƒ³ã‚¸è‰²ã®æ¨ªç·šï¼‰
                    const refLine2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    
                    // â˜…ãƒ‡ãƒãƒƒã‚°: åŸºæº–é«˜ã•Â±5pxã®ç¯„å›²ï¼ˆè–„ã„ã‚ªãƒ¬ãƒ³ã‚¸ï¼‰
                    const refRange2 = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                         
                    // â˜…ãƒ‡ãƒãƒƒã‚°: å³å´æ¤œå‡ºç¯„å›²ï¼ˆã‚·ã‚¢ãƒ³ï¼‰
                    const rightRange2 = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    
                    // â˜…è¿½åŠ : è¨˜å·ã®ä¸­å¿ƒXåº§æ¨™
                    let sigCenterX2 = aR.left + (aR.width / 2);                    
                    let debugInfo2 = {
                        id: `M${midSigCounter}`,
                        type: sigType2,
                        sigTop: aR.top.toFixed(1),
                        sigHeight: aR.height.toFixed(1),
                        sigLeft: aR.left.toFixed(1),
                        sigWidth: aR.width.toFixed(1),
                        sigCenterX: sigCenterX2.toFixed(1),
                        yOffsetRatio: yOffsetRatio2,
                        referenceY: sigReferenceY2.toFixed(1),
                        nearNotes: []
                    };
                    
                    let noteCounter2 = 1;

                    
                    heads.forEach(h => {
                        const hRect = h.getBoundingClientRect();
                        const hTop = hRect.top + window.scrollY;
                        const isSameStaff = Math.abs(hTop - myC.top) < 60;
                        if (isSameStaff) {
                            // â˜…è¿½åŠ : éŸ³ç¬¦ã®ä¸­å¿ƒXåº§æ¨™
                            const noteCenterX2 = hRect.left + (hRect.width / 2);
                            const distanceX2 = noteCenterX2 - sigCenterX2;
                            
                            const distance = hRect.left - aR.right;
                            const heightDiff = hRect.top - sigReferenceY2;
                            
                            // â˜…ä¿®æ­£: å³å´ã®è·é›¢ï¼ˆä¸­å¿ƒé–“ï¼‰ãŒ23pxæœªæº€
                            const isCloseInX2 = distanceX2 > 0 && distanceX2 < 23.0;
                            
                            // â˜…è¿½åŠ : å·¦å´ã®è·é›¢ã‚‚ç¢ºèªï¼ˆ8åˆ†éŸ³ç¬¦ã®æ——å¯¾ç­–ï¼‰
                            const distanceNegX2 = sigCenterX2 - noteCenterX2;
                            const isCloseInNegX2 = distanceNegX2 > 0 && distanceNegX2 < 10.0;
                            
                            // é«˜ã•åˆ¤å®šã¯å‚è€ƒå€¤ã¨ã—ã¦æ®‹ã™ãŒã€åˆ¤å®šã«ã¯ä½¿ã‚ãªã„
                            const isSameHeight = Math.abs(hRect.top - sigReferenceY2) < 1.3;
                            const isNoteOnRight = hRect.left > aR.right - 5 && hRect.left < aR.right + 15;

                            // è¿‘æ¥éŸ³ç¬¦ã®ã¿è¨˜éŒ²
                            if (Math.abs(distance) < 50 || isCloseInX2 || isCloseInNegX2) {
                                debugInfo2.nearNotes.push({
                                    noteNum: noteCounter2,
                                    noteLeft: hRect.left.toFixed(1),
                                    noteTop: hRect.top.toFixed(1),
                                    noteCenterX: noteCenterX2.toFixed(1),
                                    sigCenterX: sigCenterX2.toFixed(1),
                                    distanceX: distanceX2.toFixed(1),
                                    distanceNegX: distanceNegX2.toFixed(1),
                                    distance: distance.toFixed(1),
                                    heightDiff: heightDiff.toFixed(1),
                                    isNoteOnRight: isNoteOnRight,
                                    isSameHeight: isSameHeight,
                                    isCloseInX: isCloseInX2,
                                    isCloseInNegX: isCloseInNegX2,
                                    willTrigger: isCloseInX2 || isCloseInNegX2
                                });
                                
                                // â˜…ãƒ‡ãƒãƒƒã‚°: éŸ³ç¬¦ä½ç½®ãƒãƒ¼ã‚«ãƒ¼
                                const noteMarker2 = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                                                 
                                // â˜…ãƒ‡ãƒãƒƒã‚°: éŸ³ç¬¦ç•ªå·
                                const noteLabel2 = document.createElementNS("http://www.w3.org/2000/svg", "text");
                                
                            }

                            // â˜…ä¿®æ­£: Xåº§æ¨™è¿‘æ¥åˆ¤å®šï¼ˆå³å´ã¾ãŸã¯å·¦å´ï¼‰
                            if (isCloseInX2 || isCloseInNegX2) {
                                isTooCloseToNote = true;
                                // â˜…ãƒ‡ãƒãƒƒã‚°: ãƒãƒƒãƒã—ãŸç·š
                                const matchLine2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
                                             }
                        }
                    });

                     console.log(`%c[${debugInfo2.id}]`, 'color: purple; font-weight: bold; font-size: 16px;',
                        `åˆ¤å®š: ${isTooCloseToNote ? 'ğŸš« è‡¨æ™‚è¨˜å·(ã‚¹ã‚­ãƒƒãƒ—)' : 'âœ… èª¿å·(å‡¦ç†)'}`,
                        `\nè¨˜å·ã‚¿ã‚¤ãƒ—: ${debugInfo2.type}`,
                        `\nè¨˜å·ä½ç½®: top=${debugInfo2.sigTop}, left=${debugInfo2.sigLeft}, width=${debugInfo2.sigWidth}`,
                        `\nè¨˜å·ä¸­å¿ƒX: ${debugInfo2.sigCenterX}`,
                        `\nyOffsetRatio: ${debugInfo2.yOffsetRatio}`,
                        `\nåŸºæº–é«˜ã•: ${debugInfo2.referenceY}`,
                        `\nè¿‘æ¥éŸ³ç¬¦:`, debugInfo2.nearNotes);
                    
                    midSigCounter++;


                    if (!isTooCloseToNote) {
                        const ratio = aR.height / aR.width;
                        let type = "none";
                        if (ratio >= 3.45) type = "natural";
                        else if (ratio >= 3.25 && ratio <= 3.44) type = "sharp";
                        else if (ratio >= 3.1 && ratio <= 3.24) type = "flat";

                        if (type !== "none") {
                            console.log(`è­œä¸­ã®èª¿å·: ç¸¦æ¨ªæ¯”=${ratio.toFixed(3)}, ã‚¿ã‚¤ãƒ—=${type}`);
                            let yOffsetRatio = (type === "flat") ? 0.78 : (type === "natural" ? 0.5 : 0.55);
                            let baseAdjustedY = aR.top - scoreRect.top + (aR.height * yOffsetRatio) - 1;
                            const startX = aR.left - scoreRect.left;
                            extendedKeySigs.push({ type, y: baseAdjustedY, clef: myC, left: aR.left });
                            
                            // const midKeySigKey... (å‰Šé™¤)
                            // æç”»
                            const l1 = drawGuideLine(svgLayer, baseAdjustedY, scoreRect.width, "rgba(255, 0, 255, 0.8)", "1", startX);
                            if(l1) l1.setAttribute("class", "guide-keysig");

                            [-1, 1].forEach(octave => {
                                let octY = baseAdjustedY - (myC.height * 1.10 * octave);
                                extendedKeySigs.push({ type, y: octY, clef: myC, left: aR.left });
                                // æç”»
                                const l2 = drawGuideLine(svgLayer, octY, scoreRect.width, "rgba(255, 0, 255, 0.4)", "0.5", startX);
                                if(l2) l2.setAttribute("class", "guide-keysig");
                            });
                            
                            // drawnElements.keySigs.add(midKeySigKey); (å‰Šé™¤)
                            
                            const midAccBox = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                            midAccBox.setAttribute("x", aR.left - scoreRect.left - 2);
                            midAccBox.setAttribute("y", aR.top - scoreRect.top - 2);
                            midAccBox.setAttribute("width", aR.width + 4);
                            midAccBox.setAttribute("height", aR.height + 4);
                            midAccBox.setAttribute("fill", "none");
                            midAccBox.setAttribute("stroke", "#ff00ff");
                            midAccBox.setAttribute("stroke-width", "2");
                            midAccBox.setAttribute("class", "guide-keysig");
                            svgLayer.appendChild(midAccBox);
                        }
                    }
                }
            });

            // ========== ç¬¬3æ®µéš: èª¿å·ã«ã‚ˆã‚‹é‹æŒ‡è¨ˆç®— ==========
            heads.forEach(head => {
                const r = head.getBoundingClientRect();
                const nTopAbs = r.top + window.scrollY;

                const myC = clefs.reduce((p, c) => Math.abs(c.top - nTopAbs) < Math.abs(p.top - nTopAbs) ? c : p, clefs[0]);
                if (!myC || !isStaffFullyVisible(myC)) return;
                
                // æç”»æ¸ˆã¿ã‚¯ãƒ¬ãƒ•ã¯ã‚¹ã‚­ãƒƒãƒ—
                const clefKey = myC.top.toFixed(1);
                if (drawnClefs.has(clefKey)) return;

                const hasLocalAcc = activeAccidentals.some(a => r.left >= a.left && r.left <= a.right && Math.abs(r.top - a.top) < 2);
                
                if (!hasLocalAcc) {
                    const matchedSig = extendedKeySigs.find(s => {
                        if (s.clef.top !== myC.top) return false;
                        if (r.left < (s.left - 2)) return false;
                        const nCenterY = r.top - scoreRect.top + (r.height * 0.5);
                        const threshold = myC.height / 30;
                        return Math.abs(nCenterY - s.y) < threshold;
                    });

                    if (matchedSig) {
                        const finalSig = extendedKeySigs.filter(s => {
                            if (s.clef.top !== myC.top) return false;
                            if (r.left < (s.left - 2)) return false;
                            const nCenterY = r.top - scoreRect.top + (r.height * 0.5);
                            const threshold = myC.height / 30;
                            return Math.abs(nCenterY - s.y) < threshold;
                        }).reduce((prev, curr) => (curr.left > prev.left) ? curr : prev, matchedSig);

                        const relX = r.left - scoreRect.left + (r.width / 2);
                        const relY = r.top - scoreRect.top;
                        
                        svgLayer.querySelectorAll(".finger-label").forEach(l => {
                            if (Math.abs(parseFloat(l.getAttribute("x")) - relX) < 1 && Math.abs(parseFloat(l.getAttribute("y")) - (relY + 30)) < 1) l.remove();
                        });

                        const baseRatio = (nTopAbs - myC.top) / myC.height;
                        let finger = "?", color = "#000000";

                        if (currentInstrument === 'bass') {
                            // ã‚³ãƒ³ãƒˆãƒ©ãƒã‚¹ã®é‹æŒ‡è¨ˆç®—
             if (baseRatio < -0.80) finger = "10"; else if (baseRatio < -0.65) finger = "9";
        else if (baseRatio < -0.50) finger = "7"; else if (baseRatio < -0.35) finger = "5";
        else if (baseRatio < -0.20) finger = "4"; else if (baseRatio < -0.05) finger = "2";
        else if (baseRatio < 0.10) finger = "0"; else if (baseRatio < 0.28) finger = "3";
        else if (baseRatio < 0.38) finger = "2"; else if (baseRatio < 0.48) finger = "0";
        else if (baseRatio < 0.78) finger = "3"; else if (baseRatio < 0.88) finger = "2";
        else if (baseRatio < 0.98) finger = "0"; else if (baseRatio < 1.18) finger = "3";
        else if (baseRatio < 1.38) finger = "1"; else finger = "0";
if (baseRatio < 0.10) color = "#2ecc71";
                else if (baseRatio < 0.48) color = "#3498db";
                else if (baseRatio < 0.98) color = "#e74c3c";
                else color = "#000000";
    } else {
        // ãƒã‚§ãƒ­ã®é‹æŒ‡è¨ˆç®—
	     if (baseRatio < -1.40) finger = "12"; else if (baseRatio < -1.25) finger = "11";
	else if (baseRatio < -1.10) finger = "9"; else if (baseRatio < -0.95) finger = "7";
	else if (baseRatio < -0.80) finger = "5"; else if (baseRatio < -0.65) finger = "4";
        else if (baseRatio < -0.50) finger = "2"; else if (baseRatio < -0.35) finger = "0";
        else if (baseRatio < -0.20) finger = "4"; else if (baseRatio < -0.05) finger = "2";
        else if (baseRatio < 0.10) finger = "0"; else if (baseRatio < 0.28) finger = "3";
        else if (baseRatio < 0.38) finger = "2"; else if (baseRatio < 0.48) finger = "0";
        else if (baseRatio < 0.78) finger = "3"; else if (baseRatio < 0.88) finger = "2";
        else if (baseRatio < 0.98) finger = "0"; 
if (baseRatio < -0.35) color = "#2ecc71";
    else if (baseRatio < 0.10) color = "#3498db";
    else if (baseRatio < 0.48) color = "#e74c3c";
    else color = "#000000";
    }
                        
                        let fNum = parseInt(finger);
                        if (finalSig.type === "sharp") {
                            fNum += 1;
                            // ãƒã‚§ãƒ­ã®å ´åˆ: é’4â†’ç·‘0ã¸ã®ç§»å‹•
                            if (currentInstrument === 'cello' && fNum === 5 && color === "#3498db") {
                                finger = "0";
                                color = "#2ecc71";
                                fNum = 0; // å¾Œç¶šå‡¦ç†ã®ãŸã‚æ›´æ–°
                            }
                        }
                        else if (finalSig.type === "flat") {
                            if (fNum === 0) {
                                finger = "4";
                                // æ¥½å™¨åˆ¥ã®è‰²å¤‰æ›´å‡¦ç†
                                if (currentInstrument === 'bass') {
                                    // ã‚³ãƒ³ãƒˆãƒ©ãƒã‚¹: å¼¦ç§»å‹•ã«ã‚ˆã‚‹è‰²å¤‰æ›´
				ã€€ã€€if (color === "#2ecc71") color = "#3498db";
                                    else if (color === "#3498db") color = "#e74c3c";
                                    else if (color === "#e74c3c") color = "#000000";
                                } else {
                                    // ãƒã‚§ãƒ­: å¼¦ç§»å‹•ã«ã‚ˆã‚‹è‰²å¤‰æ›´
                                    if (color === "#2ecc71") color = "#3498db";
                                    else if (color === "#3498db") color = "#e74c3c";
                                    else if (color === "#e74c3c") color = "#000000";
                                }
                            } else fNum -= 1;
                        }
                        else if (finalSig.type === "doubleflat") {
                            if (fNum === 0) {
                                finger = "3";
                                // æ¥½å™¨åˆ¥ã®è‰²å¤‰æ›´å‡¦ç†
                                if (currentInstrument === 'bass') {
                                    // ã‚³ãƒ³ãƒˆãƒ©ãƒã‚¹: è‰²å¤‰æ›´ãªã—
                                } else {
                                    // ãƒã‚§ãƒ­: å¼¦ç§»å‹•ã«ã‚ˆã‚‹è‰²å¤‰æ›´
                                    if (color === "#2ecc71") color = "#3498db";
                                    else if (color === "#3498db") color = "#e74c3c";
                                    else if (color === "#e74c3c") color = "#000000";
                                }
                            } else if (fNum === 1) {
                                finger = "4";
                                // æ¥½å™¨åˆ¥ã®è‰²å¤‰æ›´å‡¦ç†
                                if (currentInstrument === 'bass') {
                                    // ã‚³ãƒ³ãƒˆãƒ©ãƒã‚¹: è‰²å¤‰æ›´ãªã—
                                } else {
                                    // ãƒã‚§ãƒ­: å¼¦ç§»å‹•ã«ã‚ˆã‚‹è‰²å¤‰æ›´
                                    if (color === "#2ecc71") color = "#3498db";
                                    else if (color === "#3498db") color = "#e74c3c";
                                    else if (color === "#e74c3c") color = "#000000";
                                }
                            } else if (fNum >= 2) {
                                fNum -= 2;
                                finger = fNum.toString();
                            }
                        }
                        
                        // ç·‘è‰²ã®4ã®ç‰¹åˆ¥å‡¦ç†
                        if (color !== "#2ecc71") {
                            if (finger !== "4" || matchedSig.type === "sharp") finger = fNum.toString();
                        } else {
                            finger = fNum.toString();
                        }

                        const txt = document.createElementNS("http://www.w3.org/2000/svg", "text");
                        txt.setAttribute("x", relX);
                        txt.setAttribute("y", relY + 30);
                        txt.setAttribute("fill", color);
                        txt.setAttribute("font-size", "18px");
                        txt.setAttribute("font-weight", "bold");
                        txt.setAttribute("text-anchor", "middle");
                        txt.setAttribute("class", "finger-label");
                        txt.textContent = finger;
                        svgLayer.appendChild(txt);

                        // èª¿å·ã®å½±éŸ¿ã‚’å—ã‘ãŸéŸ³ç¬¦ã®ãƒ”ãƒ³ã‚¯æ å›²ã¿
                        const pinkRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                        pinkRect.setAttribute("x", r.left - scoreRect.left - 2);
                        pinkRect.setAttribute("y", r.top - scoreRect.top - 2);
                        pinkRect.setAttribute("width", r.width + 4);
                        pinkRect.setAttribute("height", r.height + 4);
                        pinkRect.setAttribute("fill", "none");
                        pinkRect.setAttribute("stroke", "#ff00ff");
                        pinkRect.setAttribute("stroke-width", "2");
                        pinkRect.setAttribute("class", "guide-keysig");
                        svgLayer.appendChild(pinkRect);
                    }
                }
            });

	    // å‡¦ç†å®Œäº†ã—ãŸäº”ç·šè­œã‚’æç”»æ¸ˆã¿ã¨ã—ã¦è¨˜éŒ²
            clefs.forEach(c => {
                if (isStaffFullyVisible(c)) {
                    const clefKey = c.top.toFixed(1);
                    drawnClefs.add(clefKey);
                }
            });

            // ä¼‘ç¬¦ã¨é‡ãªã‚‹æŒ‡ç•ªå·ã‚’å‰Šé™¤
            const labels = svgLayer.querySelectorAll(".finger-label");
            labels.forEach(label => {
                const lRect = label.getBoundingClientRect();
                let shouldRemove = false;

                allPaths.forEach(p => {
                    const pRect = p.getBoundingClientRect();
                    const isRest = pRect.height > 15 && pRect.height < 28 && pRect.width > 5 && pRect.width < 15;
                    
                    // ã‚ˆã‚Šå³å¯†ãªé‡ãªã‚Šåˆ¤å®šï¼ˆç¸¦æ–¹å‘ã‚’20pxã«ç¸®å°ï¼‰
                    const isOverlapX = lRect.left < pRect.right && lRect.right > pRect.left;
                    const isOverlapY = Math.abs(lRect.top - pRect.top) < 20;
                    
                    if (isRest && isOverlapX && isOverlapY) {
                        shouldRemove = true;
                    }
                });

                if (shouldRemove) {
                    label.remove();
                    
                    // åŒã˜ä½ç½®ã«ã‚ã‚‹ãƒ”ãƒ³ã‚¯ã®æ ã‚‚å‰Šé™¤ï¼ˆå³å¯†ãªé‡ãªã‚Šåˆ¤å®šã‚’ä½¿ç”¨ï¼‰
                    svgLayer.querySelectorAll("rect[stroke='#ff00ff']").forEach(rect => {
                        const rRect = rect.getBoundingClientRect();
                        
                        const isOverlapX = lRect.left < rRect.right && lRect.right > rRect.left;
                        const isOverlapY = Math.abs(lRect.top - rRect.top) < 25;
                        
                        if (isOverlapX && isOverlapY) {
                            rect.remove();
                        }
                    });
                    
                    // åŒã˜ä½ç½®ã«ã‚ã‚‹è‡¨æ™‚è¨˜å·ã®è‰²ä»˜ãæ ã‚‚å‰Šé™¤
                    svgLayer.querySelectorAll("rect[stroke='#9b59b6'], rect[stroke='#3498db'], rect[stroke='#2ecc71'], rect[stroke='#e74c3c'], rect[stroke='#f39c12']").forEach(rect => {
                        const rRect = rect.getBoundingClientRect();
                        
                        const isOverlapX = lRect.left < rRect.right && lRect.right > rRect.left;
                        const isOverlapY = Math.abs(lRect.top - rRect.top) < 25;
                        
                        if (isOverlapX && isOverlapY) {
                            rect.remove();
                        }
                    });
                }
            });

            // --- ä»Šå›å‡¦ç†ã—ãŸäº”ç·šè­œã‚’ã€Œå‡¦ç†æ¸ˆã¿ãƒªã‚¹ãƒˆã€ã«ç¢ºå®šç™»éŒ² ---
            currentPassClefs.forEach(key => processedClefs.add(key));
// --- ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«åˆ¤å®šã¨å®Ÿè¡Œ ---
            // ãƒšãƒ¼ã‚¸ã®æœ€ä¸‹éƒ¨ï¼ˆä½™è£•ã‚’è¦‹ã¦-10pxï¼‰ã«åˆ°é”ã—ã¦ã„ãŸã‚‰çµ‚äº†
            if (window.scrollY + window.innerHeight >= document.body.scrollHeight - 10) {
                break;
}

            // â˜…å¤‰æ›´ç®‡æ‰€: behavior: 'smooth' ã‚’ä½¿ç”¨ã—ã¦æ»‘ã‚‰ã‹ã«ç§»å‹•
            window.scrollBy({
                top: window.innerHeight * 0.7,
                behavior: 'smooth'
            });
            // â˜…å¤‰æ›´ç®‡æ‰€: ã‚¹ãƒ ãƒ¼ã‚¹ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ™‚é–“ã‚’è€ƒæ…®ã—ã€å¾…æ©Ÿæ™‚é–“ã‚’1.2ç§’ã«èª¿æ•´
            await new Promise(r => setTimeout(r, 2000)); 
        } // whileãƒ«ãƒ¼ãƒ—çµ‚äº†
        
        // â˜†å¤‰æ›´ç®‡æ‰€: çµ‚äº†å¾Œã®æˆ»ã‚Šã‚‚æ»‘ã‚‰ã‹ã«ã™ã‚‹å ´åˆ
        window.scrollTo({ top: 0, behavior: 'smooth' });
        document.getElementById('input-blocker').style.display = 'none'; // ã‚¿ãƒƒãƒ/ã‚¯ãƒªãƒƒã‚¯ãƒ–ãƒ­ãƒƒã‚¯è§£é™¤
        document.body.style.overflow = ''; // â˜†ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç¦æ­¢ã‚’è§£é™¤(å…ƒã®çŠ¶æ…‹ã«æˆ»ã™)
        
        accBtn.disabled = false;
        keyBtn.disabled = false;
    };

        function drawGuideLine(layer, y, width, color, opacity, startX = 0) {
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", startX);
            line.setAttribute("y1", y);
            line.setAttribute("x2", width);
            line.setAttribute("y2", y);
            line.setAttribute("stroke", color);
            line.setAttribute("stroke-width", "1");
            line.setAttribute("stroke-dasharray", "4,2");
            line.setAttribute("opacity", opacity);
            layer.appendChild(line);
            return line;
        }

        function setupToggleButtons() {
            const accBtn = document.getElementById('toggle-acc-btn');
            if (accBtn) {
                accBtn.onclick = function() {
                    const elements = document.querySelectorAll('.guide-accidental');
                    const isHidden = this.classList.toggle('is-hidden');
                    elements.forEach(el => { el.style.visibility = isHidden ? 'hidden' : 'visible'; });
                    this.innerText = isHidden ? 'è‡¨æ™‚è¨˜å·ã‚¬ã‚¤ãƒ‰è¡¨ç¤º' : 'è‡¨æ™‚è¨˜å·ã‚¬ã‚¤ãƒ‰éè¡¨ç¤º';
                    this.classList.toggle('active-acc', !isHidden);
                };
            }

            const keyBtn = document.getElementById('toggle-key-btn');
            if (keyBtn) {
                keyBtn.onclick = function() {
                    const elements = document.querySelectorAll('.guide-keysig');
                    const isHidden = this.classList.toggle('is-hidden');
                    elements.forEach(el => { el.style.visibility = isHidden ? 'hidden' : 'visible'; });
                    this.innerText = isHidden ? 'èª¿å·ã‚¬ã‚¤ãƒ‰è¡¨ç¤º' : 'èª¿å·ã‚¬ã‚¤ãƒ‰éè¡¨ç¤º';
                    this.classList.toggle('active-key', !isHidden);
                };
            }
        }

        window.addEventListener('DOMContentLoaded', setupToggleButtons);

        // ========== PDFä¿å­˜æ©Ÿèƒ½ï¼ˆæ”¹å–„ç‰ˆï¼‰ ==========
        document.getElementById('pdf-btn').onclick = async function() {
            if (!osmd) {
                alert('å…ˆã«æ¥½è­œã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„');
                return;
            }

            const btn = this;
            const status = document.getElementById('status');
            const originalText = btn.innerText;
            btn.disabled = true;
            btn.innerText = "PDFç”Ÿæˆä¸­...";
            
            try {
                const wrapper = document.getElementById('wrapper');
                const scoreContainer = document.getElementById('score-container');
                const wrapperRect = wrapper.getBoundingClientRect();
                
                // â˜…ä¿®æ­£: å®Ÿéš›ã®è¡¨ç¤ºå¹…(1000pxç­‰)ã‚’åŸºæº–ã«ã™ã‚‹
                const pageWidth = wrapper.clientWidth; 
                const pageHeight = pageWidth * Math.sqrt(2); // A4æ¯”ç‡
                
                status.innerText = "æ¥½è­œã®æ§‹é€ ã‚’è§£æä¸­...";
                // äº”ç·šè­œï¼ˆã‚¯ãƒ¬ãƒ•ï¼‰ã®æ¤œå‡º
                const allPaths = Array.from(scoreContainer.querySelectorAll("path"));
                const clefs = allPaths.filter(p => {
                    const r = p.getBoundingClientRect();
                    // ã‚µã‚¤ã‚ºãƒã‚§ãƒƒã‚¯
                    if (r.height < 20 || r.height > 70 || r.width < 15 || r.width > 55) return false;
                    
                    // ã¸éŸ³è¨˜å·ã®ç¸¦æ¨ªæ¯”ãƒã‚§ãƒƒã‚¯ï¼ˆç¸¦é•·ã®è¨˜å·ã®ã¿ï¼‰
                    const aspectRatio = r.height / r.width;
                    return aspectRatio >= 1.1 && aspectRatio <= 1.5;
                }).map(c => {
                    const r = c.getBoundingClientRect();
                    return { 
                        top: r.top - wrapperRect.top,
                        bottom: r.bottom - wrapperRect.top,
                        height: r.height,
                        element: c 
                    };
                }).sort((a, b) => a.top - b.top);
                
                if (clefs.length === 0) {
                    throw new Error('æ¥½è­œã®äº”ç·šè­œã‚’æ¤œå‡ºã§ãã¾ã›ã‚“ã§ã—ãŸ');
                }
                
                // å„äº”ç·šè­œã®ã€Œä¿è­·ã‚¨ãƒªã‚¢ã€ã‚’å®šç¾©ï¼ˆã‚¯ãƒ¬ãƒ•ã®ä¸­å¿ƒã‹ã‚‰ä¸Šä¸‹ã«ä½™è£•ã‚’æŒãŸã›ã‚‹ï¼‰
                const staffProtectedAreas = clefs.map(clef => {
                    const clefCenter = clef.top + (clef.height / 2);
                   
                    // â˜…ä¿®æ­£: äº”ç·šè­œåŠåˆ†(16px) + ä¸Šä¸‹ä½™ç™½34px = 50px
                    const verticalMargin = 52; 
                    
                    return {
                        top: clefCenter - verticalMargin,
                        bottom: clefCenter + verticalMargin,
                        clefTop: clef.top
                    };
                });
                
                // æ”¹ãƒšãƒ¼ã‚¸ä½ç½®ã®æœ€é©åŒ–ï¼ˆå†å¸°çš„è¡çªãƒã‚§ãƒƒã‚¯ä»˜ãï¼‰
                const optimalPageBreaks = [];
                let currentPageBottom = pageHeight;
                
                while (currentPageBottom < wrapper.offsetHeight) {
                    let breakPosition = currentPageBottom;
                    let adjusted = false;
                    let iterations = 0;
                    const maxIterations = 20; // ç„¡é™ãƒ«ãƒ¼ãƒ—é˜²æ­¢
                    
                    // è¡çªãŒãªããªã‚‹ã¾ã§ç¹°ã‚Šè¿”ã—ãƒã‚§ãƒƒã‚¯
                    do {
                        adjusted = false;
                        
                        // ã“ã®æ”¹ãƒšãƒ¼ã‚¸ä½ç½®ãŒä¿è­·ã‚¨ãƒªã‚¢ã¨è¡çªã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                        for (let area of staffProtectedAreas) {
                            if (area.top < breakPosition && area.bottom > breakPosition) {
                                // è¡çª: ã“ã®äº”ç·šè­œã®æ‰‹å‰ã§æ”¹ãƒšãƒ¼ã‚¸
                                const newPosition = area.top - 20; // 20pxã®ä½™è£•
                                
                                // å‰å›ã®æ”¹ãƒšãƒ¼ã‚¸ä½ç½®ã‚ˆã‚Šå¾Œã‚ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
                                if (optimalPageBreaks.length > 0) {
                                    const lastBreak = optimalPageBreaks[optimalPageBreaks.length - 1].position;
                                    if (newPosition > lastBreak + 100) {
                                        breakPosition = newPosition;
                                        adjusted = true;
                                        break;
                                    } else {
                                        // å‰ã®æ”¹ãƒšãƒ¼ã‚¸ã«è¿‘ã™ãã‚‹å ´åˆã¯ã€äº”ç·šè­œã®ä¸‹ã«ç§»å‹•
                                        breakPosition = area.bottom + 20;
                                        adjusted = true;
                                        break;
                                    }
                                } else {
                                    breakPosition = newPosition;
                                    adjusted = true;
                                    break;
                                }
                            }
                        }
                        
                        iterations++;
                        if (iterations >= maxIterations) {
                            console.warn('æ”¹ãƒšãƒ¼ã‚¸èª¿æ•´ãŒåæŸã—ã¾ã›ã‚“ã§ã—ãŸ');
                            break;
                        }
                    } while (adjusted);
                    
                    // æœ€çµ‚ãƒã‚§ãƒƒã‚¯: ã“ã®ãƒšãƒ¼ã‚¸ã«å°‘ãªãã¨ã‚‚1ã¤ã®äº”ç·šè­œãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹
                    const previousBreak = optimalPageBreaks.length > 0 
                        ? optimalPageBreaks[optimalPageBreaks.length - 1].position 
                        : 0;
                    
                    const hasStaffInThisPage = staffProtectedAreas.some(area => 
                        area.top >= previousBreak && area.bottom <= breakPosition
                    );
                    
                    // ãƒšãƒ¼ã‚¸ã«äº”ç·šè­œãŒãªã„å ´åˆã¯ã€æ¬¡ã®äº”ç·šè­œã®ç›´å‰ã¾ã§å»¶é•·
                    if (!hasStaffInThisPage && breakPosition < wrapper.offsetHeight) {
                        const nextStaff = staffProtectedAreas.find(area => area.top > breakPosition);
                        if (nextStaff) {
                            breakPosition = nextStaff.top - 20;
                        }
                    }
                    
                    optimalPageBreaks.push({
                        position: breakPosition,
                        adjusted: iterations > 1
                    });
                    
                    currentPageBottom = breakPosition + pageHeight;
                }
                
                console.log('æ”¹ãƒšãƒ¼ã‚¸ä½ç½®:', optimalPageBreaks);
                
                // html2canvasã§ã‚­ãƒ£ãƒ—ãƒãƒ£ï¼ˆé«˜ç”»è³ªã®ãŸã‚scale:2ã«å¤‰æ›´ï¼‰
                status.innerText = "æ¥½è­œã‚’ç”»åƒåŒ–ä¸­...";
                const canvas = await html2canvas(wrapper, { 
                    scale: 2, 
                    useCORS: true, 
                    backgroundColor: "#ffffff",
                    logging: false,
                    windowWidth: wrapper.scrollWidth,
                    windowHeight: wrapper.scrollHeight
                });
                // PDFã®ç”Ÿæˆ
                status.innerText = "PDFãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆä¸­...";
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF('p', 'mm', 'a4');
                const pdfPageWidth = pdf.internal.pageSize.getWidth();
                
                // â˜…ä¿®æ­£: html2canvasã®scaleã«åˆã‚ã›ã‚‹
                const scale = 2;
                let previousBreak = 0;
                let isFirstPage = true;
                
                // å„ãƒšãƒ¼ã‚¸ã‚’åˆ†å‰²ã—ã¦è¿½åŠ 
                for (let i = 0; i <= optimalPageBreaks.length; i++) {
                    const breakPosition = i < optimalPageBreaks.length 
                        ? optimalPageBreaks[i].position 
                        : wrapper.offsetHeight;
                        
                    // â˜…ä¿®æ­£: æ•´æ•°ä¸¸ã‚ã‚’è¡Œã£ã¦1pxã®ã‚ºãƒ¬ã‚’é˜²ã
                    const sliceTop = Math.floor(previousBreak * scale);
                    const sliceHeight = Math.floor((breakPosition - previousBreak) * scale);
                    
                    if (sliceHeight <= 0) continue;
                    if (!isFirstPage) {
                        pdf.addPage();
                    }
                    
                    // ä¸€æ™‚ã‚­ãƒ£ãƒ³ãƒã‚¹ã«ç¾åœ¨ã®ãƒšãƒ¼ã‚¸ã‚’ã‚³ãƒ”ãƒ¼
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = canvas.width;
                    tempCanvas.height = Math.min(sliceHeight, canvas.height - sliceTop);
                    
                    const ctx = tempCanvas.getContext('2d');
                    ctx.drawImage(
                        canvas, 
                        0, sliceTop, 
                        canvas.width, tempCanvas.height,
                        0, 0, 
                        canvas.width, tempCanvas.height
                    );
                    const sliceData = tempCanvas.toDataURL('image/jpeg', 0.95);
                    
                    // PDFä¸Šã§ã®ã‚µã‚¤ã‚ºè¨ˆç®—ï¼ˆç¸¦æ¨ªæ¯”ã‚’æ­£ã—ãç¶­æŒï¼‰
                    // â˜…é‡è¦: pageWidthå¤‰æ•°ã‚’wrapperå¹…ã«åˆã‚ã›ã¦ã„ã‚‹ãŸã‚ã€ã“ã®è¨ˆç®—ã§ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ãŒç¶­æŒã•ã‚Œã¾ã™
                    const actualSliceHeightInPx = tempCanvas.height / scale;
                    const pdfSliceHeight = (actualSliceHeightInPx / pageWidth) * pdfPageWidth;
                    
                    pdf.addImage(sliceData, 'JPEG', 0, 0, pdfPageWidth, pdfSliceHeight);
                    
                    previousBreak = breakPosition;
                    isFirstPage = false;
                }
                
                const instName = currentInstrument === 'cello' ? 'cello' : 'bass';
                pdf.save(`score_${instName}_fingering.pdf`);
                status.innerText = "PDFã®ä¿å­˜ãŒå®Œäº†ã—ã¾ã—ãŸ";
                
            } catch (error) {
                console.error('PDFç”Ÿæˆã‚¨ãƒ©ãƒ¼:', error);
                status.innerText = "PDFä½œæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿ: " + error.message;
                alert("ã‚¨ãƒ©ãƒ¼è©³ç´°: " + error.message + "\n\nã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚");
            } finally {
                btn.disabled = false;
                btn.innerText = originalText;
            }
        };

    </script>
</body>
</html>
